<link rel="import" href="../../../bower_components/polymer/polymer-element.html">
<script src="dragon.min.js" async></script>
<script src="abis.js" async></script>

<dom-module id="function-newitem">
    <script>
        class FunctionNewItem extends Polymer.Element {
            static get is() {
                return 'function-newitem';
            }
            /**
            * create a deal object
            * @param {string} privateKey - The private key to sign the message with
            * @param {string} message - The message to be signed
            * @param {string} address - The address associated with the private key
            * @param {string} date - The date to append to the message
            * @param {string} location - The date to append to the message
            * @param {string} swtvalue - The date to append to the message
            * @return {object}
            */
            newItem(privateKey, message, address, date, location, swtvalue) {
                return new Promise((resolve, reject) => {
                    if (privateKey && message && address && date && location && swtvalue) {

                        // First create the transaction
                        var simpleDealContract = new dragon.Contract(abis.hashtag.abi);
                        var encodedSimpleDealTx = simpleDealContract.methods.makeDealForTwo("0x4e03657aea45a94fc7d47ba826c8d667c0d1e6e33a64a036ec44f58fa12d6c45", 600000000000000000, "ipfshash").encodeABI();

                        const rawTx = {
                          nonce: window.kf[3].nonce++,
                          gasPrice: 1500000000000000,
                          gasLimit: 200000,
                          to: "0x9a166b528a59A993Fd9dce2035f912F9EB2783c6",
                          value: "600000000000000000",
                          data: encodedSimpleDealTx,
                          chainId: 1
                        };

                        var tx = new dragon.Transaction(rawTx);
                        var serializedtx = dragon.addHexPrefix(tx.serialize().toString('hex'));




                        // Then we can call approveAndCall on the SWT contract
                        var swtContract = new dragon.Contract(abis.miniMeToken.abi, "0x9a166b528a59A993Fd9dce2035f912F9EB2783c6");
                        debugger;
                          swtContract.methods.approveAndCall("0x3fE6c29a5854D55d5B685B9C3502B885a6B2599B", 1200000000000000000, serializedtx).estimateGas({from: window.kf[3].publicKey})
                        .then(function(gasAmount){
                             var gasNeeded = gasAmount;
                             debugger;
                         }).catch(function(error){
                             console.log('error in gasamaount');
                         });

                        const approveRawTx = {
                          nonce: 10,
                          gasPrice: 1500000000000000,
                          gasLimit: 200000,
                          to: "0x9a166b528a59A993Fd9dce2035f912F9EB2783c6",
                          value: "600000000000000000",
                          data: encodedAllowance,
                          chainId: 1
                        };

                        var approvetx = new dragon.Transaction(approveRawTx);

                        approvetx.sign(privateKey);
                        var signedApproveTx = dragon.addHexPrefix(approvetx.serialize().toString('hex'));

                        // Deliver it to the API
                        socket.emit('processTx', signedApproveTx);
                        // Then we get the txhash back from the API, indicating the successful injection
                        //var txHash = "0x000";

                        resolve(signedApproveTx);

                    } else {
                        reject(Error('Missing Arguments'));
                    }
                });
            }

            /**
            * verify a signed message
            * @return {string} address - The address that signed the message
            * @param {string} signature - The final signature starting with 0x
            * @param {string} suppliedMessage - The message before it was signed
            */
            verifyMessage(signature, suppliedMessage) {
                return new Promise((resolve, reject) => {
                    if (signature && suppliedMessage) {
                        const {v, r, s} = dragon.fromRpcSig(signature);
                        const message = dragon.toBuffer(dragon.sha3(suppliedMessage));
                        const publicKey = dragon.ecrecover(message, v, r, s);
                        const addressBuffer = dragon.publicToAddress(publicKey);
                        const address = dragon.bufferToHex(addressBuffer);
                        resolve(address.toLowerCase());
                    } else {
                        reject(Error('Missing Arguments'));
                    }
                });
            }
        } window.customElements.define(FunctionNewItem.is, FunctionNewItem);
    </script>
</dom-module>

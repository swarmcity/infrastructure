<link rel="import" href="../../../bower_components/polymer/polymer-element.html">
<script src="dragon.min.js" async></script>
<script src="abis.js" async></script>
<script src="web3.min.js" async></script>

<dom-module id="function-newitem">
    <script>
        class FunctionNewItem extends Polymer.Element {
            static get is() {
                return 'function-newitem';
            }
            /**
            * create a deal object
            * @param {string} privateKey - The private key to sign the message with
            * @param {string} message - The message to be signed
            * @param {string} address - The address associated with the private key
            * @param {string} date - The date to append to the message
            * @param {string} location - The date to append to the message
            * @param {string} swtvalue - The date to append to the message
            * @return {object}
            */
            newItem(privateKey, message, address, date, location, swtvalue) {
                return new Promise((resolve, reject) => {
                    if (privateKey && message && address && date && location && swtvalue) {
                        // We will connect to web3 metamask for now because I can't dragonize the Contract function
                        var web3sc = new Web3();
                        var simpleDealContract = web3sc.eth.contract(abis.hashtag.abi);
                        //var swtContract = window.web3.eth.contract(abis.miniMeToken.abi,"0xb9e7f8568e08d5659f5d29c4997173d84cdf2607");
                        // create deal object
                        // First SHA the dealId
                        var secretCode = "randomNumber";
                        var dealId = "FlurkelSponnetDeal"+secretCode;
                        var shaDealId = web3sc.utils.sha3(dealId);
                        simpleDealContract.makeDealForTwo.encodeABI(shaDealId, 10, "QfIPFS", {
                          from: from,
                          gasPrice: gasPrice,
                          gas: gasNeeded
                        }, function(err, makeDealForTwoTx) {
                          if (err) {
                            //return cb(err);
                          }
                          //cb(null, makeDealForTwoTx, extratx);
                          console.log(err, makeDealForTwoTx, extratx);
                        });
                        //dragon.abi();
                        // Sign tx
                        var signedMsg = '0x000'
                        resolve(signedMsg);
                    } else {
                        reject(Error('Missing Arguments'));
                    }
                });
            }

            /**
            * verify a signed message
            * @return {string} address - The address that signed the message
            * @param {string} signature - The final signature starting with 0x
            * @param {string} suppliedMessage - The message before it was signed
            */
            verifyMessage(signature, suppliedMessage) {
                return new Promise((resolve, reject) => {
                    if (signature && suppliedMessage) {
                        const {v, r, s} = dragon.fromRpcSig(signature);
                        const message = dragon.toBuffer(dragon.sha3(suppliedMessage));
                        const publicKey = dragon.ecrecover(message, v, r, s);
                        const addressBuffer = dragon.publicToAddress(publicKey);
                        const address = dragon.bufferToHex(addressBuffer);
                        resolve(address.toLowerCase());
                    } else {
                        reject(Error('Missing Arguments'));
                    }
                });
            }
        } window.customElements.define(FunctionNewItem.is, FunctionNewItem);
    </script>
</dom-module>

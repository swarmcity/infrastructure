<link rel="import" href="../../../bower_components/polymer/polymer-element.html">
<script src="dragon.min.js" async></script>
<script src="abis.js" async></script>

<dom-module id="function-newitem">
    <script>
        class FunctionNewItem extends Polymer.Element {
            static get is() {
                return 'function-newitem';
            }
            /**
            * create a deal object
            * @param {string} privateKey - The private key to sign the message with
            * @param {string} message - The message to be signed
            * @param {string} address - The address associated with the private key
            * @param {string} date - The date to append to the message
            * @param {string} location - The date to append to the message
            * @param {string} swtvalue - The date to append to the message
            * @param {number} hashtagfee - The fee of the hashtag at the time of the deal, each party pays half.
            * @return {object}
            */
            newItem(privateKey, message, address, date, location, swtvalue, hashtagfee) {
                return new Promise((resolve, reject) => {
                    if (privateKey && message && address && date && location && swtvalue) {

                        // Let's get the gas price.
                        socket.emit('getGasPrice', function(gasPrice){
                          var gasPrice = gasPrice;
                          console.log("gasprice from API: ", gasPrice);
                        });

                        // Call the api for checkApproval
                        // Here we need to check if the pubkey already has given an allowance
                        var _hashtagAddress = "0x9a166b528a59A993Fd9dce2035f912F9EB2783c6";
                        var _publicKey = window.kf[3].publicKey;
                        var data = {
                          hashtagAddress: _hashtagAddress,
                          publicKey: _publicKey,
                          allowanceNeeded: (hashtagfee / 2) + swtvalue
                        };

                        // Setting up some ingredients
                        var swtContract = new dragon.Contract(abis.miniMeToken.abi, "0xb9e7f8568e08d5659f5d29c4997173d84cdf2607");
                        var simpleDealContract = new dragon.Contract(abis.hashtag.abi, "0x9a166b528a59A993Fd9dce2035f912F9EB2783c6");

                        // [kf] @will this is shit code but i just want to make dealmaking work in a first frontend iteration

                        // The socket gets the approvalStatus back.
                        // 0: everything okay, no allowance found
                        // 1: there's an allowance set, but it is not enough to cover this tx
                        // 2: there's an allowance set, and it's enough to cover this tx

                        socket.emit('checkApprovalStatus', data, function(_approvalStatus){
                          var approvalStatus = _approvalStatus;
                          console.log("approvalstatus from API: ", approvalStatus);
                          switch (approvalStatus.approvalStatus) {
                            case 0:
                              console.log('i can make the deal!');
                              // create approval, chain the dealmaking
                              this.estimateGas(approve).then((gasNeeded) => {
                                this.approve("0x9a166b528a59A993Fd9dce2035f912F9EB2783c6", data.allowanceNeeded, gasNeeded, gasPrice, from, privateKey).then((txhash) => {
                                  this.makeDeal(deal).then((txhash) => resolve(txhash));
                                });
                              });
                              break;
                            case 1:
                              console.log('the allowance set is not enough');
                              // go to set allowance to zero, than the right amount, then do the dealmaking
                              // Estimate gas for the allowance setting to zero
                              // we need to set it to zero first
                              // https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit
                              this.estimateGas(approve).then((gasNeeded) => {
                                this.approveTx("0x9a166b528a59A993Fd9dce2035f912F9EB2783c6", 0, gasNeeded, gasPrice, from, privateKey).then(()=>{
                                  this.estimateGas(approve).then((gasNeeded) => {
                                    this.approveTx("0x9a166b528a59A993Fd9dce2035f912F9EB2783c6", 0, gasNeeded, gasPrice, from, privateKey).then(()=>{
                                      this.makeDeal(deal).then((txhash)=>{ resolve(txhash)}));
                                    });
                                  });
                                });
                              });
                              break;

                            case 2:
                              console.log('the allowance set is high enough');
                              // go to dealmaking without allowance
                              this.makeDeal(deal).then((txhash)=>{ resolve(txhash)}));
                              break;
                            case 3:
                              console.log('an error occured');
                          }
                        });

                        //Deliver it to the API
                        socket.emit('processTx', signedApproveTx);
                        console.log(signedApproveTx);
                        resolve(': err? ');

                    } else {
                        reject(Error('Missing Arguments'));
                    }
                });
            }

            /**
            * estimateGas price for an approve call
            * @return {number} gasNeeded - The amount of gas needed to execute the tx / in wei
            * @param {string} spender - The final signature starting with 0x
            * @param {number} allowance - The amount of swt tokens to be allowed / in smallest 1e18
            * @param {string} from - The public key
            */
            estimateGas(_spender, _allowance, _from) {
              return new Promise((resolve, reject)=>{
                var swtContract = new dragon.Contract(abis.miniMeToken.abi, "0xb9e7f8568e08d5659f5d29c4997173d84cdf2607");
                swtContract.methods.approve(_spender, _allowance).estimateGas({from: _from})
                .then(function(gasAmount){
                     var gasNeeded = gasAmount;
                     resolve(gasNeeded);
                 }).catch(function(error){
                     console.log('error in gasamaount');
                     reject(Error('Missing Arguments'));
                 });
              });
            }

            /**
            * makeDeal creates the actual deal
            * @return {string} txHash - The tx hash
            * @param {object} deal - The dealobject
            */
            makeDeal(_deal) {
              return new Promise((resolve, reject) => {
                var simpleDealContract = new dragon.Contract(abis.hashtag.abi, "0x9a166b528a59A993Fd9dce2035f912F9EB2783c6");
                var encodedSimpleDealTx = simpleDealContract.methods.makeDealForTwo("0x4e03657aea45a94fc7d47ba826c8d667c0d1e6e33a64a036ec44f58fa12d6c45", 600000000000000000, "ipfshash").encodeABI();

                const rawTx = {
                  to: "0x9a166b528a59A993Fd9dce2035f912F9EB2783c6",
                  data: encodedSimpleDealTx,
                  gasPrice: gasPrice,
                  gasNeeded: "SPONNETKNOWS"
                };

                var tx = new dragon.Transaction(rawTx);
                tx.sign(_privatekey);
                var serializedtx = dragon.addHexPrefix(tx.serialize().toString('hex'));
                resolve(serializedtx);
              } else {
                reject(Error('Missing arguments'));
              });
            }

            /**
            * approveTx creates the actual deal
            * @return {string} txHash - The signedtx
            * @param {string} spender - The final signature starting with 0x
            * @param {number} allowance - The amount of swt tokens to be allowed / in smallest 1e18
            * @param {string} from - The public key
            */
            approveTx(_spender, _allowance, _gasNeeded, _gasPrice, _from, _privatekey) {
              return new Promise((resolve, reject) => {
                var swtContract = new dragon.Contract(abis.miniMeToken.abi, "0xb9e7f8568e08d5659f5d29c4997173d84cdf2607");
                var encodedtx = swtContract.methods.approve("0x9a166b528a59A993Fd9dce2035f912F9EB2783c6", 1200000000000000000, serializedtx).encodeABI();
                const rawTx = {
                  to: "0x9a166b528a59A993Fd9dce2035f912F9EB2783c6",
                  data: encodedtx,
                  gasPrice: _gasPrice,
                  gasNeeded: _gasNeeded
                };
                var approvetx = new dragon.Transaction(rawTx);
                approvetx.sign(_privatekey);
                var signedApproveTx = dragon.addHexPrefix(approvetx.serialize().toString('hex'));
                resolve(signedApproveTx);
              } else {
                reject(Error('Missing arguments'));
              });
            }

            /**
            * verify a signed message
            * @return {string} address - The address that signed the message
            * @param {string} signature - The final signature starting with 0x
            * @param {string} suppliedMessage - The message before it was signed
            */
            verifyMessage(signature, suppliedMessage) {
                return new Promise((resolve, reject) => {
                    if (signature && suppliedMessage) {
                        const {v, r, s} = dragon.fromRpcSig(signature);
                        const message = dragon.toBuffer(dragon.sha3(suppliedMessage));
                        const publicKey = dragon.ecrecover(message, v, r, s);
                        const addressBuffer = dragon.publicToAddress(publicKey);
                        const address = dragon.bufferToHex(addressBuffer);
                        resolve(address.toLowerCase());
                    } else {
                        reject(Error('Missing Arguments'));
                    }
                });
            }


        } window.customElements.define(FunctionNewItem.is, FunctionNewItem);
    </script>
</dom-module>

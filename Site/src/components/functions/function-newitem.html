<link rel="import" href="../../../bower_components/polymer/polymer-element.html">
<script src="dragon.min.js" async></script>
<script src="abis.js" async></script>

<dom-module id="function-newitem">
    <script>
        class FunctionNewItem extends Polymer.Element {
            static get is() {
                return 'function-newitem';
            }
            /**
            * create a deal object
            * @param {string} privateKey - The private key to sign the message with
            * @param {string} message - The message to be signed
            * @param {string} address - The address associated with the private key
            * @param {string} date - The date to append to the message
            * @param {string} location - The date to append to the message
            * @param {string} swtvalue - The date to append to the message
            * @param {number} hashtagfee - The fee of the hashtag at the time of the deal, each party pays half.
            * @return {object}
            */
            newItem(privateKey, message, address, date, location, swtvalue, hashtagfee) {
                return new Promise((resolve, reject) => {
                    if (privateKey && message && address && date && location && swtvalue) {

                        // Call the api for checkApproval
                        // Here we need to check if the pubkey already has given an allowance
                        var _hashtagAddress = "0x9a166b528a59A993Fd9dce2035f912F9EB2783c6";
                        var _publicKey = window.kf[3].publicKey;
                        const _privatekey = privateKey;
                        var dealIdInternal = 'abc';
                        var data = {
                          //dealIdInternal: dragon.uuid.v4();
                          dealIdInternal: dealIdInternal,
                          dealIdExternal: dragon.addHexPrefix(dragon.sha3(dealIdInternal).toString('hex')),
                          hashtagAddress: _hashtagAddress,
                          publicKey: _publicKey,
                          privateKey: privateKey,
                          allowanceNeeded: (hashtagfee / 2) + swtvalue,
                          dealValue: swtvalue
                        };


                        // Setting up some ingredients
                        var swtContract = new dragon.Contract(abis.miniMeToken.abi, "0xb9e7f8568e08d5659f5d29c4997173d84cdf2607");
                        var simpleDealContract = new dragon.Contract(abis.hashtag.abi, "0x9a166b528a59A993Fd9dce2035f912F9EB2783c6");

                        // [kf] @will this is shit code but i just want to make dealmaking work in a first frontend iteration

                        // The socket gets the approvalStatus back.
                        // 0: everything okay, no allowance found
                        // 1: there's an allowance set, but it is not enough to cover this tx
                        // 2: there's an allowance set, and it's enough to cover this tx

                        var self = this;

                        socket.emit('checkApprovalStatus', data, function(_approvalStatus){
                          var approvalStatus = _approvalStatus;
                          switch (approvalStatus.approvalStatus) {
                            case 0:
                              // create approval, chain the dealmaking
                              var approve = {
                                spender: "0x9a166b528a59A993Fd9dce2035f912F9EB2783c6",
                                from: window.kf[3].publicKey,
                                allowance: data.allowanceNeeded
                              }
                              self.estimateGas("0x9a166b528a59A993Fd9dce2035f912F9EB2783c6", data.allowanceNeeded, window.kf[3].publicKey).then((gasNeeded) => {
                                self.approve("0x9a166b528a59A993Fd9dce2035f912F9EB2783c6", data.allowanceNeeded, gasNeeded, gasPrice, from, privateKey).then((txhash) => {
                                  self.makeDeal(data).then((txhash) => resolve(txhash));
                                });
                              });
                              break;
                            case 1:
                              // go to set allowance to zero, than the right amount, then do the dealmaking
                              // Estimate gas for the allowance setting to zero
                              // we need to set it to zero first
                              // https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit

                              self.estimateGas("0x9a166b528a59A993Fd9dce2035f912F9EB2783c6", data.allowanceNeeded, window.kf[3].publicKey).then((gasNeeded) => {
                                self.getGasPrice().then((result)=>{
                                  self.approveTx("0x9a166b528a59A993Fd9dce2035f912F9EB2783c6", 0, gasNeeded, result, window.kf[3].publicKey, privateKey).then(()=>{
                                    self.estimateGas("0x9a166b528a59A993Fd9dce2035f912F9EB2783c6", data.allowanceNeeded, window.kf[3].publicKey).then((gasNeeded) => {
                                      data.gasPrice = parseInt(result);
                                      data.gasNeeded = gasNeeded;
                                      self.approveTx("0x9a166b528a59A993Fd9dce2035f912F9EB2783c6", data.allowanceNeeded, data.gasNeeded, data.gasPrice, window.kf[3].publicKey, data.privateKey).then(()=>{
                                        self.makeDeal(data).then((txhash)=>{
                                          resolve(txhash);
                                        });
                                      });
                                    });
                                  });
                                });
                              });
                              break;

                            case 2:
                              // go to dealmaking without allowance
                              this.makeDeal(data).then((txhash)=>{ resolve(txhash) });
                              break;
                            case 3:
                              console.log('an error occured');
                          }
                        });

                        //Deliver it to the API
                        // socket.emit('processTx', signedApproveTx);
                        // console.log(signedApproveTx);
                        //resolve(': err? ');

                    } else {
                        reject(Error('Missing Arguments'));
                    }
                });
            }


            /**
            * getGasPrice returns the current gas price
            * @return {number} gasprice - The gasprice
            */
            getGasPrice() {
              return new Promise((resolve, reject)=>{
                // Let's get the gas price.
                socket.emit('getGasPrice', function(gasPrice){
                  var gasPrice = gasPrice;
                  console.log("gasprice from API: ", gasPrice);
                  resolve(gasPrice.gasPrice);
                });
              });
            }

            /**
            * estimateGas price for an approve call
            * @return {number} gasNeeded - The amount of gas needed to execute the tx / in wei
            * @param {string} spender - The final signature starting with 0x
            * @param {number} allowance - The amount of swt tokens to be allowed / in smallest 1e18
            * @param {string} from - The public key
            */
            estimateGas(_spender, _allowance, _from) {
              return new Promise((resolve, reject)=>{
                //var swtContract = new dragon.Contract(abis.miniMeToken.abi, "0xb9e7f8568e08d5659f5d29c4997173d84cdf2607");
                //swtContract.methods.approve(_spender, _allowance).estimateGas({from: _from})
                var data = {
                  spender: _spender,
                  from: _from,
                  allowance: _allowance
                };
                socket.emit('estimateGas', data, function(_gasNeeded){
                  var gasNeeded = _gasNeeded.gasNeeded;
                  console.log("estimategas from API: ", gasNeeded);
                  resolve(gasNeeded);
                });
              });
            }

            /**
            * makeDeal creates the actual deal
            * @return {string} txHash - The tx hash
            * @param {object} deal - The dealobject
            */
            makeDeal(_deal) {
              return new Promise((resolve, reject) => {
                var simpleDealContract = new dragon.Contract(abis.hashtag.abi, "0x9a166b528a59A993Fd9dce2035f912F9EB2783c6");
                var encodedSimpleDealTx = simpleDealContract.methods.makeDealForTwo(_deal.dealIdExternal, _deal.dealValue, "ipfshash").encodeABI();

                const rawTx = {
                  nonce: window.kf[3].nonce++,
                  to: _deal.hashtagAddress,
                  data: encodedSimpleDealTx,
                  gasPrice: _deal.gasPrice,
                  gasLimit: 300009
                };

                var tx = new dragon.Transaction(rawTx);
                tx.sign(_deal.privateKey);

                var serializedtx = dragon.addHexPrefix(tx.serialize().toString('hex'));
                // emit it to the api > processTx

            });
          }

            /**
            * approveTx creates the actual deal
            * @return {string} txHash - The signedtx
            * @param {string} spender - The final signature starting with 0x
            * @param {number} allowance - The amount of swt tokens to be allowed / in smallest 1e18
            * @param {string} from - The public key
            * @param {number} gasNeeded - The public key
            * @param {number} gasPrice - The public key
            */
            approveTx(_spender, _allowance, _gasNeeded, _gasPrice, _from, _privatekey) {
              return new Promise((resolve, reject) => {
                var swtContract = new dragon.Contract(abis.miniMeToken.abi, "0xb9e7f8568e08d5659f5d29c4997173d84cdf2607");

                var encodedtx = swtContract.methods.approve(_spender, _allowance).encodeABI();
                var gasPrice = parseInt(_gasPrice);

                const rawTx = {
                  nonce: window.kf[3].nonce++,
                  to: "0xb9e7f8568e08d5659f5d29c4997173d84cdf2607",
                  data: encodedtx,
                  gasPrice: gasPrice,
                  gasLimit: _gasNeeded,
                  value: 0
                };

                var approvetx = new dragon.Transaction(rawTx);

                approvetx.sign(_privatekey);
                var signedApproveTx = dragon.addHexPrefix(approvetx.serialize().toString('hex'));
                console.log('---> first inject the approve tx ', signedApproveTx);
                // wait for the txhash to come back from the API and then go on

                resolve(signedApproveTx);
              });
            }


            /**
            * verify a signed message
            * @return {string} address - The address that signed the message
            * @param {string} signature - The final signature starting with 0x
            * @param {string} suppliedMessage - The message before it was signed
            */
            verifyMessage(signature, suppliedMessage) {
                return new Promise((resolve, reject) => {
                    if (signature && suppliedMessage) {
                        const {v, r, s} = dragon.fromRpcSig(signature);
                        const message = dragon.toBuffer(dragon.sha3(suppliedMessage));
                        const publicKey = dragon.ecrecover(message, v, r, s);
                        const addressBuffer = dragon.publicToAddress(publicKey);
                        const address = dragon.bufferToHex(addressBuffer);
                        resolve(address.toLowerCase());
                    } else {
                        reject(Error('Missing Arguments'));
                    }
                });
            }

            processTx(signedTx) {
              return new Promise((resolve, reject) => {
                socket.emit('processTx', signedTx, function(_txhash){
                  resolve(_txhash);
                });
              } else {
                  reject(Error('Missing Arguments'));
              });
            }




        } window.customElements.define(FunctionNewItem.is, FunctionNewItem);
    </script>
</dom-module>
